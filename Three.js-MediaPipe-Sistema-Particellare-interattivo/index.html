<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Interactive Particles 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; }
        .input_video { display: none; }
        .output_canvas { position: absolute; bottom: 10px; left: 10px; width: 120px; height: 90px; border: 1px solid #444; z-index: 5; transform: scaleX(-1); }
        #status { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 5px; z-index: 10; font-family: sans-serif; }
		.output_canvas {
			position: absolute;
			bottom: 20px;
			left: 20px;
			width: 200px; /* Aumentiamo un po' la dimensione */
			height: 150px;
			border: 2px solid #00ffee; /* Un bordo colorato per capire se esiste */
			border-radius: 10px;
			z-index: 100; /* Deve stare sopra tutto */
			transform: scaleX(-1); /* Effetto specchio */
			background: #222; /* Colore di fondo se la camera è spenta */
		}
    </style>
</head>
<body>

    <div id="status">Inizializzazione Camera...</div>
    <video class="input_video"></video>
    <canvas class="output_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.0/dist/tweakpane.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const status = document.getElementById('status');
        
        // --- SETUP PARAMETRI ---
        const params = {
            color: '#00ffee',
            shape: 'Sfera',
            particleCount: 8000,
            size: 0.04,
            lerpSpeed: 0.05
        };

        let handDistance = 0.05;
        
        let targetRotationX = 0;
        let targetRotationY = 0;

        // --- THREE.JS SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(params.particleCount * 3);
        const targetPositions = new Float32Array(params.particleCount * 3);
        
        for (let i = 0; i < params.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 10;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            size: params.size,
            color: params.color,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png')
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);
        camera.position.z = 5;

        // --- FORME ---
        function setShape(type) {
            for (let i = 0; i < params.particleCount; i++) {
                const i3 = i * 3;
                let x, y, z;
                if (type === 'Sfera') {
                    const u = Math.random(), v = Math.random();
                    const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                    x = 2 * Math.sin(phi) * Math.cos(theta);
                    y = 2 * Math.sin(phi) * Math.sin(theta);
                    z = 2 * Math.cos(phi);
                } else if (type === 'Cuore') {
                    const t = Math.random() * Math.PI * 2;
                    x = 0.15 * (16 * Math.pow(Math.sin(t), 3));
                    y = 0.15 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    z = (Math.random() - 0.5) * 0.5;
                } else if (type === 'Saturno') {
                    if (i < params.particleCount * 0.5) {
                        const u = Math.random(), v = Math.random();
                        const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                        x = 1.5 * Math.sin(phi) * Math.cos(theta);
                        y = 1.5 * Math.sin(phi) * Math.sin(theta);
                        z = 1.5 * Math.cos(phi);
                    } else {
                        const a = Math.random() * Math.PI * 2;
                        const r = 2.2 + Math.random() * 1.0;
                        x = r * Math.cos(a); y = (Math.random()-0.5)*0.1; z = r * Math.sin(a);
                    }
                }
                targetPositions[i3] = x; targetPositions[i3+1] = y; targetPositions[i3+2] = z;
            }
        }
        setShape('Sfera');

        // --- UI ---
        const pane = new Tweakpane.Pane();
        pane.addInput(params, 'color').on('change', (v) => material.color.set(v.value));
        pane.addInput(params, 'shape', { options: { Sfera: 'Sfera', Cuore: 'Cuore', Saturno: 'Saturno' } }).on('change', (v) => setShape(v.value));

        // --- MEDIAPIPE ---
        const videoElement = document.querySelector('.input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`});
        
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
		const canvasElement = document.querySelector('.output_canvas');
		const canvasCtx = canvasElement.getContext('2d');

		hands.onResults((results) => {
			// 1. Pulisci il canvas della camera
			canvasCtx.save();
			canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
			
			// 2. Disegna l'immagine della telecamera sul piccolo canvas
			canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

			// 3. Disegna i punti della mano (opzionale, ma utile per debug)
			if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
				const h = results.multiHandLandmarks[0];
				
				// Calcolo distanza per Three.js
				handDistance = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);

                targetRotationY = (h[0].x - 0.5) * Math.PI * 2; 
                targetRotationX = (h[0].y - 0.5) * Math.PI;

				// Disegna un cerchio sui punti 4 (pollice) e 8 (indice) per feedback visivo
				canvasCtx.fillStyle = "#00ffee";
				[4, 8].forEach(index => {
					const point = h[index];
					canvasCtx.beginPath();
					canvasCtx.arc(point.x * canvasElement.width, point.y * canvasElement.height, 5, 0, 2 * Math.PI);
					canvasCtx.fill();
				});
			}
			canvasCtx.restore();
		});

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        cameraFeed.start().then(() => status.innerText = "Camera Attiva");

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // --- Gestione Posizione Particelle (Scaling) ---
            const pos = geometry.attributes.position.array;
            const scale = 0.5 + handDistance * 8; 
            for (let i = 0; i < params.particleCount * 3; i++) {
                pos[i] += (targetPositions[i] * scale - pos[i]) * params.lerpSpeed;
            }
            geometry.attributes.position.needsUpdate = true;

            // --- Gestione Rotazione (Webcam) ---
            // Applichiamo la rotazione con un effetto smooth
            points.rotation.y += (targetRotationY - points.rotation.y) * 0.1;
            points.rotation.x += (targetRotationX - points.rotation.x) * 0.1;

            // Un po' di rotazione automatica continua per profondità
            points.rotation.y += 0.002;

            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>